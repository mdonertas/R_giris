% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\title{R'a Giriş}
\author{H. Melike Dönertaş}
\date{16-04-2022}

\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={R'a Giriş},
  pdfauthor={H. Melike Dönertaş},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\renewcommand{\chaptermark}[1]{\markboth{{\chaptername\ \thechapter.\ #1}}{}}
\renewcommand{\sectionmark}[1]{\markright{{\thesection.\ #1}}{}}
\usepackage[turkish]{babel}
\usepackage{float}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{section}{%
\chapter*{}\label{section}}
\addcontentsline{toc}{chapter}{}

Bu kitap oluşturulma aşamasında olup, zamanla güncellenecek, yeni bölümler eklenecektir.

\hypertarget{Giris}{%
\chapter{Giriş}\label{Giris}}

\hypertarget{r-nedir}{%
\section{R nedir?}\label{r-nedir}}

R ile ilgili şimdiye kadar en uygun bulduğum, en çok hoşuma giden benzetme Matthew Keller'a ait. Keller diyor ki: `R is like a magic, except you have functions instead of spells' - yani diyor ki R büyü gibidir, ancak büyülü sözcükler yerine fonksiyonlarınız vardır. SPSS, SAS kullanıcıları, `muggle' gibidir. Ortamı değiştirme kabiliyetleri sınırlıdır. Onların analizi için birileri tarafından uygun görülmüş dizayn edilmiş algoritmalarla sınırlıdırlar ve üstüne para ödemek zorundadırlar. Keller, R programcıları ise `büyücü'lere benzetiyor. R programcılar, alanında uzman olan kişiler tarafından yazılmış fonksiyonlara (yani büyülere) bağlı kalarak devam edebilecekleri gibi, kendi büyülerini de yaratabilirler ('sectumsempra' gibi lanetler de mümkün tabii). Bunları kullanmak / bunlara erişmek için para ödemezler, ve yeterinde deneyim kazandıklarında yapamayacakları bir şey yoktur.

\hypertarget{r-avantajlarux131}{%
\section{R Avantajları}\label{r-avantajlarux131}}

\begin{itemize}
\tightlist
\item
  Ücretsiz!
\item
  Açık kaynak kodlu
\item
  Aktif ve dinamik bir komünitesi var. Yardım almak çok kolay.
\item
  Güncel
\item
  Kod yazarken analiz hakkında düşünmeniz gerekiyor. Bu sebeple yaptığınız analizin, deney düzeneğinize, örnekleminize ve en önemlisi hipotezinize uygun olup olmadığını tartabiliyorsunuz. Rastgele tuşlara tıklayıp p\textless0.05 görünce alıp devam etmekten oldukça farklı!
\item
  İstatistiksel testlerin varsayımlarına bağlı kalmadan, simülasyonlar ile empirik dağılımlar yaratıp test yapabilirsiniz.
\item
  R notebook / R markdown gibi dökümanlar oluşturarak analizinizi / deneyinizi takip etmeyi ve yayınlamayı kolaylaştırmak ve tekrar edilebilirliğini sağlamak mümkün.
\item
  Özellikle rutin olarak biyoistatistik / biyoenformatik çalışmıyorsanız, Windows kullanıcısı olma ihtimaliniz yüksek. R işletim sisteminden bağımsız olduğundan, kendi bilgisayarınızda çalışabilir, ve gerektiğinde analizinizi / kodunuzu başka platformlarda çalışanlarla rahatlıkla paylaşabilirsiniz.
\item
  Bilim dili günümüzde İngilizce imiş gibi gözüküyor. Ben buna katılmıyorum. Bilimin dili bence grafikler. Yazdığınız 15 sayfalık bir makaleyi özetleyebilecek 3 grafik yapabilmek çok büyük bir güç (büyük konuştum, tabii her şeyi grafikleştirmek mümkün değil ama zamanla makaleleri okurken farketmeye başlıyor insan Excel, Graph Pad grafiklerinin R'da oluşturulmuş grafikler yanında nasıl kaldığını\ldots)
\item
  Bir de öğrenmesi en kolay dillerden birisi. Ancak bunun yanında öğrenme eğrisi lineer değil. Yani ilk zamanlar çok zor gelebilir (ilk zamanlar çok basit olmasına rağmen kaç defa matrisin satırı yerine sütunu ile işlem yapmaya çalıştığımı anlatamam bile!) ama alıştıktan sonra insanın kendisini geliştirmesi, yeni fonksiyon hatta başkalarının kullanımı için paket yazmak diğer dillere göre çok daha kolay.
\item
  Son olarak, R paket sayısı, paketlerin güncellenme sıklığı, paket yazarlarının ulaşılabilirliği açısından özellikle biyoloji alanında çalışanlar açısından çok avantajlı. \texttt{Bioconductor} projesi özellikle biyoloji ile alakalı analizler için -omics data analizi için vs.~inanılmaz avantaj sağlıyor.
\end{itemize}

\hypertarget{r-uxf6ux11frenmeye-nasux131l-baux15flarux131m}{%
\section{R Öğrenmeye Nasıl Başlarım?}\label{r-uxf6ux11frenmeye-nasux131l-baux15flarux131m}}

Bu sorunun tabii ki kesin net bir cevabı yok, kişiden kişiye, kullanımdan kullanıma farklılık gösterecektir en verimli yol. Ama yine de bir takım basamaklardan geçmemek imkansız (R'ı bilgisayarınıza indirmek ve kurmak gibi!). İlk olarak bu `mutlaka olması gereken maddeler' ve yararlı bulduğum kimi basamakları sıralayalım.

\hypertarget{r-kurulumu}{%
\subsection{R kurulumu}\label{r-kurulumu}}

Çok basit: \href{https://cran.r-project.org}{CRAN Anasayfası}na gidip, kullandığımız işletim sistemi için olan versiyonu indiriyoruz. Bir çok kullanıcı için `base' sürümü yeterli olacaktır. Sonrasında talimatları takip ederek R'ı kuruyoruz.

\hypertarget{rstudio}{%
\subsection{RStudio}\label{rstudio}}

R'ın kendi arayüzü oldukça sade ve yeterli olsa da, ben herkese \href{https://www.rstudio.com/}{RStudio}'yu indirmelerini tavsiye ediyorum. RStudio da ücretsiz ve R programlama için bir çeşit arayüz gibi düşünebilirsiniz.

\hypertarget{kaynaklar}{%
\subsection{Kaynaklar}\label{kaynaklar}}

\hypertarget{online-dersler}{%
\subsubsection{Online Dersler}\label{online-dersler}}

\begin{itemize}
\tightlist
\item
  \href{https://www.edx.org/course/statistics-r-harvardx-ph525-1x-1}{EdX - Statistics and R dersi} ve ogrendikten sonra~dersin devami
\item
  \href{https://www.coursera.org/learn/r-programming}{Coursera - R Programming dersi}
\item
  \href{https://swirlstats.com/}{R'ı R içinde öğrenin - swirl paketi}
\end{itemize}

\hypertarget{bloglar}{%
\subsubsection{Bloglar}\label{bloglar}}

\begin{itemize}
\tightlist
\item
  \href{https://www.r-bloggers.com/}{R Blogger}
\end{itemize}

\hypertarget{kitaplar}{%
\subsubsection{Kitaplar}\label{kitaplar}}

\begin{itemize}
\tightlist
\item
  \href{http://www.cookbook-r.com/Graphs/}{R Graphics Cookbook - ggplot and more}
\end{itemize}

\hypertarget{rstudio}{%
\chapter{RStudio Arayüzü}\label{rstudio}}

\begin{figure}
\centering
\includegraphics{images/rstudio.png}
\caption{RStudio Arayüzü}
\end{figure}

İlk olarak çalışacağımız ortamı tanıyalım.

RStudio'yu açtığınızda `RStudio Arayüzü' resmine çok benzer bir tablo ile karşılacaksınız - belki 4. kısım hariç, oraya geleceğiz. Arkaplan muhtemelen beyazdır ve belki işletim sistemi farkları söz konusudur. Ama yine de bu ekran aşağı yukarı neresı ne işe yarıyor, kodu nereye yazacağız gibi kısa bir giriş yapmak için yeterli olacaktır.

\hypertarget{konsol-terminal-1}{%
\section{Konsol, Terminal (1)}\label{konsol-terminal-1}}

\textbf{Konsol (Console)}: Burası kodu yazıp sonuçları gördüğümüz kısım. Denemek için \texttt{2+2} yazıp enter'a basalım.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \SpecialCharTok{+} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\textbf{Terminal}: Burası da bilgisayarınızın terminali veya komut istemcisine erişim sağlayan bir kısım. RStudio'nun eski versiyonlarında bu özellik yoktu ancak yeni versiyon kullanıyorsanız bu sekme de mevcut olacaktır.

\hypertarget{dosyalar-uxe7izimler-paketler-yardux131m-2}{%
\section{Dosyalar, Çizimler, Paketler, Yardım (2)}\label{dosyalar-uxe7izimler-paketler-yardux131m-2}}

\textbf{Dosyalar (Files)}: İçinde bulunduğumuz klasörün içindeki dosyaları listeliyor.

\textbf{Çizimler (Plots)}: Çizdiğimiz grafikleri görüntüleyebileceğimiz kısım. Örneğin şu kodu konsola yazarak bu sekmenin işlevini gözlemleyebiliriz:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{hist}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{R_Giris_files/figure-latex/inithist-1.pdf}
\caption{\label{fig:inithist}1000 rastgele değer kullanılarak çizilmiş bir histogram}
\end{figure}

Bu ekranda büyütme, dışarı aktarma (export) gibi seçenekleri de görüyoruz. Ancak grafikleri kaydetmek için bu dışarı aktarma seçeneğini kullanmamayı, kaydetme işlemini de tamamen kod ile yapmayı tavsiye ediyorum.

\textbf{Paketler (Packages)}: R'da yüklü olan çeşitli paketleri (kütüphaneleri) görüyoruz. Ancak buradan R ortamımıza yükleme yapmaktansa \texttt{library()} komutunu kullanmalıyız ki yazdığımız kodlar daha sonra hem biz hem başkaları tarafından kolaylıkla çalıştırılabilsin. Bu kısma sonra geleceğim.

\textbf{Yardım (Help)}: Bu sekme RStudio'daki en büyük dostumuz. Açıp öğrenme linklerini kurcalamak iyi bir başlangıç. Ayrıca \texttt{?} operatörü ile burada fonksiyonların yardım sayfalarını görüntüleyebiliriz, örneğin konsolda şu kodu deneyelim:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?hist}
\end{Highlighting}
\end{Shaded}

Gördüğünüz gibi, yardım sekmesinde az önce histogram çizmek için kullandığınız \texttt{hist()} fonksiyonu için yardım ekranı açıldı. Bu ekranda, fonksiyonun tanımı, argümanları, sonucu hakkında bilgi alabiliyor ve en altta örnekleri görüyorsunuz. Örnekleri çalıştırıp, fonksiyonla ilgili daha fazla bilgi sahibi olabilirsiniz. Burada çıkan bilgiler, R'ı yüklediğimizde gelen `base R' fonksiyonları için epey detaylı. İndireceğiniz bir çok paket için de detaylı bilgi bulabilirsiniz ancak detay ve örnek miktarı paket yazarlarının oluşturduğu yardım dosyalarına bağlı olan bir şey.

\hypertarget{ortam-geuxe7miux15f-3}{%
\section{Ortam, Geçmiş (3)}\label{ortam-geuxe7miux15f-3}}

\textbf{Ortam (Environment)}: Oluşturduğumuz değişkenlerin listesini ve bilgilerini burada görebiliriz. Şunu deneyelim:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

Bu kod ile, x isimli değişkene, 3 değerini vermiş olduk. Artık sadece x yazıp enter'a basarsanız, x'in 3 olduğunu göreceksiniz. Aynı zamanda ortam sekmesinde artık x'in de listelendiğini görebilirsiniz.

\textbf{Geçmiş (History)}: Mevcut R oturumunuzda yazdığınız kodları listeleyen bir kısım. Buradan önceden çalıştırdığınız kodları görebilirsiniz. Ancak daha pratik, daha çok kullanılan bir kısa yol, konsolda iken klavyedeki yukarı ok tuşu ile önceki kodları tekrar çağırmak. Geçmiş sadece açık oturumdaki kodları kaydediyor olsa da, .Rhistory dosyası sayesinde ortamlar arası geçmiş bilgisini aktarabilirsiniz. Yine de buna bağlı kalmak yerine daha sonra tekrar kullanacağımız kodları .R scripti olarak kaydetmek çok daha elverişli olacaktır.

\hypertarget{edituxf6r-4}{%
\section{Editör (4)}\label{edituxf6r-4}}

Editör ekranı, kodlarımızı yazıp çalıştırabileceğimiz ve sonrası için yorumlarımızla beraber kaydedebileceğimiz ekran. Bu bölüm muhtemelen açık olarak başlamamıştır RStudio. Burayı açmak için, sol üst köşedeki tuş ile yeni `R script'i açabilirsiniz. Burada başka seçenekler de var, bunların ne olduğu avantajşarı hakkında sonrasında kısımlar gelecek. Şimdilik 'R script'ini seçelim. Açtığınız zaman, görüntüdeki gibi boş bir bölüm çıkacak. Önerim kodlarınızı her zaman konsol yerine burada yazmanız. RStudio'nun güzel bir özelliği burada yazdığını kodu konsolda kolay bir şekilde çalıştırmanızı sağlıyor, kopyala yapıştır yapmanıza gerek yok. Şimdi bu ekranda 2+2 yazıp, enter'a basalım. Konsolda hiç bir şey olmadığını göreceksiniz. Şimdi tekrar 2+2 nin olduğu satıra dönüp Ctrl+Enter (Mac kullanıyorsanız Cmd+Enter)'a basın. Konsolda hem kodun çalıştırıldığını hem de sonucun burada görüntülendiğini göreceksiniz (Eğer olmadıysa R Scripti seçeneğini seçmemiş olabilirsiniz). Her çalışma sonunda bu dosyayı kaydederseniz (Ctrl+S ya da Cmd+S), daha sonra yazdığınız kodlara tekrar dönme şansınız olacaktır. Daha önemlisi, buraya yazdığınız kodların içinden hatalı olanları silebilir düzenleyebilirsiniz bu sayede sadece işlevsel kodlarınız kaydolur. Geleneksel olarak scriptlerin uzantıları'.R'dır.

Bu açıkladığım panellerin yeri, sırası ve açık olup olmayacağı seçeneklerden değiştirilebilir.

Son olarak, RStudio'yu kapatırken size 'workspace'i kaydetmek isteyip istemediğinizi soracaktır. Buna benim önerim her zaman hayır demeniz, hatta seçeneklerden bunu varsayılan olarak ayarlayıp asla kaydetmemeniz. Objeleri ayrıca istediğimiz şekilde nasıl kaydedeceğimizi ilerde göreceğiz. Yine aynı şekilde history kaydetmek yerine scriptinizi kaydetmenizi ya da history kaydetseniz bile ayrıca mutlaka scriptinizi kaydetmenizi öneririm.

\hypertarget{ilkadimlar}{%
\chapter{İlk Adımlar}\label{ilkadimlar}}

Her zaman kod yazmaya başlamadan önce, en önemli basamak çalıştığımız klasörün ne olduğunu bilmek, gerekirse değiştirmek.

Hangi klasörde çalıştığımızı öğrenmek için \texttt{getwd()} fonksiyonunu kullanabiliriz (get working directory). Çalıştığımız klasörü belirlemek içinse \texttt{setwd()} fonksiyonu kullanılıyor:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "/Volumes/GoogleDrive/My Drive/githubbooks/R_Giris"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{setwd}\NormalTok{(}\StringTok{\textquotesingle{}\textasciitilde{}/Desktop\textquotesingle{}}\NormalTok{)}
\FunctionTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "/Users/melike/Desktop"
\end{verbatim}

Önerim, bilgisayarınızda R öğrenmek için bir klasör oluşturmanız ve kodunuzu, kullandığınız dosyaları vs.~hep burada tutmanız. Aynı şekilde, belirli bir amaçla R kullandığınız zaman da masaüstüne rastgele isimlerle scriptleriniz kaydetmek yerine, düzenli bir şekilde uygun klasörleri içeriğe dair fikir veren isimlendirmelerle ya da belirli bir sistemle kaydetmeniz hayatınızı kolaylaştıracaktır.

\hypertarget{hesap-makinesi-olarak-r}{%
\section{Hesap Makinesi olarak R}\label{hesap-makinesi-olarak-r}}

En temekde hesap makinesi işlemleri yapmak için kullanabilirsiniz:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\SpecialCharTok{+}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\SpecialCharTok{*}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{10{-}5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}\SpecialCharTok{\^{}}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{450}\SpecialCharTok{/}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 150
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{200}\SpecialCharTok{/}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 66.66667
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{200}\SpecialCharTok{\%\%}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{200}\SpecialCharTok{\%/\%}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 66
\end{verbatim}

Çok açık olmayan operatörler:

\begin{itemize}
\tightlist
\item
  \texttt{\%\%}-- belirli bir tabanda kalan işlemi, modüler aritmetik. Örneğimizde 200ün 3e bölümünden kalan 2
\item
  \texttt{\%/\%} -- tam sayı bölmesi, kalan olsa bile tam sayı olarak bölme işleminin sonucu
\end{itemize}

\hypertarget{fonksiyonlar}{%
\section{Fonksiyonlar}\label{fonksiyonlar}}

R kendi içinde fonksiyonlar barındırır. Örneğin, başlangıçta kullandığımız \texttt{getwd()} gibi. Farkettiysenz, fonksiyonlardan bahsederken hep parantez kullanıyorum. Fonksiyonları değişkenlerden ayırabileceğiniz en basit şekil bu. Çok basit bir kaç fonksiyona bakalım:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#10 tabaninda log}
\FunctionTok{log10}\NormalTok{(}\DecValTok{100}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#2 tabaninda log}
\FunctionTok{log2}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6.643856
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#4 tabaninda 10un log\textquotesingle{}u}
\FunctionTok{log}\NormalTok{(}\DecValTok{10}\NormalTok{,}\DecValTok{4}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.660964
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#e uzeri 1}
\FunctionTok{exp}\NormalTok{(}\DecValTok{1}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.718282
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# e uzeri 2}
\FunctionTok{exp}\NormalTok{(}\DecValTok{2}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7.389056
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
 \CommentTok{\# e uzeri 2 nin ln i {-} log taban belirtilmediginde e tabaninda islem yapar}
\FunctionTok{log}\NormalTok{(}\FunctionTok{exp}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 16 nin koku}
\DecValTok{16}\SpecialCharTok{\^{}}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# ayni islem fonksiyon ile}
\FunctionTok{sqrt}\NormalTok{(}\DecValTok{16}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\hypertarget{rda-deux11fiux15fkenler}{%
\section{R'da değişkenler}\label{rda-deux11fiux15fkenler}}

Değişkenler, veri tutucular olarak düşünülebilir. R'da değişkene değer atamak icin \texttt{=} veya \texttt{\textless{}-} operatörleri kullanılabilir. Örneğin x'e 3 değerini atamak için, aşağıdaki iki kod da geçerlidir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \DecValTok{3}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{4}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3} \SpecialCharTok{*} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{*}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12
\end{verbatim}

\texttt{\textless{}-} tarihsel olarak R camiasında çokça kullanılsa da, pratik nedenlerle \texttt{=} kullanımı da oldukça yaygın ve yanlış değildir.

\hypertarget{deux11fiux15fken-isimleri}{%
\subsection{Değişken isimleri}\label{deux11fiux15fken-isimleri}}

R'da değişkenlere verebileceğimiz isimler için bazı sınırlayıcı kurallar vardır. Değişkenler, bir harf ile ya da harfin takip ettiği nokta ile başlar. Öğrneğin, \texttt{benimdegiskenim} geçerli bir değişken isim iken \texttt{2değisken} geçerli değildir, çünkü 2 bir harf değildir. \texttt{.degisken} geçerli bir değişken ismidir ancak \texttt{.2degisken} değildir. Ayrıca R'da kimi özel anlam içeren keilemerin değişken olarak kullanılması mümkün değildir, \texttt{ìf} ve \texttt{for} gibi. Bunları \texttt{?reserved} yazarak öğrenebilirsiniz.

Yasak olmasa da diğer bir sorun R içinde varolan fonksiyonların isimleri ile değişken yaratmak. Çoğu zaman sorun olmadan çalışsa bile, karışıklığa sebep olduğu durumlar olabilir.

R'da değişken isimleri küçük / büyük harfe duyarlıdır.

Değişken isimlerini tuttuğu veriyle alakalı seçmek kolaylık sağlar.

\hypertarget{temel-obje-tuxfcrleri}{%
\chapter{Temel obje türleri}\label{temel-obje-tuxfcrleri}}

R'da 5 çeşit temel obje türü var:

\hypertarget{karakter-character}{%
\section{Karakter (character)}\label{karakter-character}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \StringTok{\textquotesingle{}a\textquotesingle{}}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Karakter değişkeni yaratmak için, tırnak işaretlerini (\texttt{\textquotesingle{}\textquotesingle{}}) kullanıyoruz. Yani, \texttt{x} bir obje iken \texttt{\textquotesingle{}a\textquotesingle{}} bir karakterdir. Bu sebeple, \texttt{a} yazdığınızda, R \texttt{a} isminde bir obje arıyor, bizim a isminde bir objemiz olmadığından \texttt{obje\ bulunamadı} hatası veriyor. Bu arada R'da en iyi dostumuz hata mesajları. Genelde hata mesajı sorunun nerede olduğu hakkında çok iyi fikir verecektir.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\texttt{class()} fonksiyonu obje sınıfını öğrenmemizi sağlıyor.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \StringTok{\textquotesingle{}melike\textquotesingle{}}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "melike"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

Karakter sınıfındaki objeler, tek bir karakter içermek zorunda değil, \texttt{\textquotesingle{}a\textquotesingle{}} da \texttt{\textquotesingle{}aaa\textquotesingle{}} da karakter objeleridir.

\hypertarget{nuxfcmerik-numeric}{%
\section{Nümerik (numeric)}\label{nuxfcmerik-numeric}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \DecValTok{3}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FloatTok{3.14}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.14
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OtherTok{=} \DecValTok{1}\SpecialCharTok{/}\DecValTok{0}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] Inf
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \DecValTok{0} \SpecialCharTok{/} \DecValTok{0}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NaN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

Burada ilginç olan kısımlar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  R tam sayıları da özellikle belirtmediğimiz sürece nümerik olarak alıyor
\item
  \texttt{Sonsuz}un (\texttt{Inf}) veri tipi nümerik
\item
  \texttt{NaN} (``not a number'', ``sayı değil'') değeri de nümerik sınıfında.
\end{enumerate}

\hypertarget{tam-sayux131lar-integer}{%
\section{Tam sayılar (integer)}\label{tam-sayux131lar-integer}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=}\NormalTok{ 3L}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

Özellikle tam sayı oluşturmak istiyorsak sondaki L ekini kullanmalıyız.

\hypertarget{kompleks-complex}{%
\section{Kompleks (complex)}\label{kompleks-complex}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \DecValTok{1}\SpecialCharTok{+}\NormalTok{4i}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1+4i
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "complex"
\end{verbatim}

\hypertarget{mantux131ksal-logical-boolean}{%
\section{Mantıksal (logical, boolean)}\label{mantux131ksal-logical-boolean}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \ConstantTok{TRUE}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "logical"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \ConstantTok{FALSE}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "logical"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=}\NormalTok{ T}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

TRUE ve FALSE iki temel mantıksal değişken (True=Doğru, False=Yanlış). Sadece baş harfleri kullanılarak da ifade edilebilirler.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=}\NormalTok{ f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in eval(expr, envir, enclos): object 'f' not found
\end{verbatim}

Ancak bu harfler büyük harf olmali yoksa \texttt{f} ismindeki objeye eşitlemeye çalışmış oluyoruz x'i.

Alıştırma olarak şu objelerin sınıflarını tahmin etmeye çalışıp, yanılıp yanılmadığınızı kontrol edebilirsiniz:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\OtherTok{=}\StringTok{\textquotesingle{}5\textquotesingle{}} 
\NormalTok{b}\OtherTok{=}\StringTok{\textquotesingle{}T\textquotesingle{}}
\NormalTok{y}\OtherTok{=}\FloatTok{10.5}\NormalTok{L}
\NormalTok{x}\OtherTok{=}\StringTok{\textquotesingle{}y\textquotesingle{}}
\NormalTok{d}\OtherTok{=}\NormalTok{x}
\end{Highlighting}
\end{Shaded}

Tırnak işaretleri içinde veriler girildiğinden \texttt{a}, \texttt{b}, \texttt{x}, ve dolayısıyla \texttt{d} objeleri karakter tipindedir. \texttt{y} ise ondalıklı değer girdiğimizden \texttt{L} uzantısını kullansak da tam sayı değil nümerik tipindedir.

İlerledikçe \texttt{class()} fonksiyonu ile objelere baktığınızda farklı cevaplar alacağız. Mesela objelerden oluşan objelerimiz olduğunda - 1den 100e kadar olan sayıları içeren 10x10luk bir matrisiniz varsa mesela (\texttt{class(matrix(1:100,10))}). Veya R'ın nesne tabalı programlama (object oriented programming) dili olmasının getirisi olarak, yeni obje sınıfları ile çalıştığınızda.

Eğer ki obje açık bir obje sınıfına sahipse (örn. matrix gibi), nümerik değerlerden oluşan bir obje mi, karakter objesi mi, bunu görmek yerine sınıfını göreceksiniz. Bu durumda \texttt{mode()} fonksiyonunu kullanarak ne tip objelerden oluştuğunu görebiliriz, örn \texttt{mode(matrix(1:100,10))}.

\hypertarget{vektuxf6rler}{%
\chapter{Vektörler}\label{vektuxf6rler}}

R kimi veri yapıları üzerinde işlem yapar. En basit veri yapılarından biri olan vektörler, aynı temel obje türünden öğeler içeren dizilerdir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

Burada `x'; 1, 2, ve 3 öğelerine sahip bir vektördür. Vektör oluşturmak için bu örnekte \texttt{c()} fonksiyonunu kullandık. \texttt{c}yi, \texttt{concatenate} (bağlamak) ya da \texttt{combine} (birleştirmek) kelimelerinden birinin kısaltılmış hali olarak aklınızda tutabilirsiniz.

Önceki örnekte nümerik tipte öğelerden oluşan bir vektör yarattık. Ancak vektörler hepsi aynı olduğu sürece diğer tiplerden de oluşabilir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(T,F,F) }\CommentTok{\# logical}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}aa\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}oiasjfioasjf\textquotesingle{}}\NormalTok{) }\CommentTok{\# character}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "x"            "y"            "aa"           "oiasjfioasjf"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{+}\NormalTok{4i,}\DecValTok{5}\SpecialCharTok{+}\NormalTok{2i) }\CommentTok{\# complex}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1+4i 5+2i
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(1L,5L) }\CommentTok{\#integer}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 5
\end{verbatim}

Şimdi de aynı tipte olmayan öğelerle vektör oluşturmaya çalıştığımızda ne oluyor, bunu görelim. İlk deneme olarak bütün tipleri girdi olarak verip bir vektör yaratmaya çalışalım.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\FloatTok{1.5}\NormalTok{, }\StringTok{\textquotesingle{}karakter\textquotesingle{}}\NormalTok{, 3i}\SpecialCharTok{+}\DecValTok{2}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, F)}
\end{Highlighting}
\end{Shaded}

Bu örnekte; nümerik, karakter, kompleks ve boolean tipinde öğelerle ile bir vektor yaratmak istedik. Ve hata almadık Peki `x' objesinin modu ne ve nasıl bir vektor elde ettik?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1.5"      "karakter" "2+3i"     "TRUE"     "FALSE"
\end{verbatim}

Hata almadık ama vektör oluşturma sırasında öğeler kendi modlarını koruyamadılar. Data tipleri arasında bir hiyerarşi vardır ve R farklı tipte öğeleri birleştirirken bu objelerde hiyerarşide en yüksek olanı seçerek vektör yaratır. Buradan yapacağımız çıkarım, karakter tipi hiyerarşide en yüksek olan. Şimdi sırasıyla en yüksekte olanı çıkartarak hiyerarşiyi çözmeye çalışalım.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# karakteri cikarttigimizda}
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\FloatTok{1.5}\NormalTok{, 3i}\SpecialCharTok{+}\DecValTok{2}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, F)}
\FunctionTok{mode}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "complex"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.5+0i 2.0+3i 1.0+0i 0.0+0i
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# kompleksi cikarttigimizda}
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\FloatTok{1.5}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, F)}
\FunctionTok{mode}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.5 1.0 0.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# numerigi cikarttigimizda}
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, F)}
\FunctionTok{mode}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "logical"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}

Bu durumda boolean \textless{} nümerik \textless{} kompleks \textless{} karakter çıkarımını yapabiliriz.

\hypertarget{vektorleri-birleux15ftirmek}{%
\section{Vektorleri birleştirmek}\label{vektorleri-birleux15ftirmek}}

Vektör yaratmak için kullandığımız c() fonksiyonu, aynı zamanda vektörleri birleştirmek için de kullanılabilir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{)}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 5 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{=} \FunctionTok{c}\NormalTok{(x,y)}
\NormalTok{z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4 5 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{=} \FunctionTok{c}\NormalTok{(z,}\DecValTok{9}\NormalTok{,}\DecValTok{8}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4 5 6 9 8
\end{verbatim}

Ve önceden bahsettiğimiz, data tipinin hiyerarşide en yüksek olana dönüştürülmesi bu durumda da geçerlidir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "b" "c"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OtherTok{=} \FunctionTok{c}\NormalTok{(x,y)}
\NormalTok{z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1" "2" "3" "a" "b" "c"
\end{verbatim}

\hypertarget{vektor-aritmetiux11fi}{%
\section{Vektor aritmetiği}\label{vektor-aritmetiux11fi}}

Daha önce R'ı hesap makinesi gibi kullanabileceğimizi görmüştük. Vektörlerle de aynı işlemleri yapabilirsiniz.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{*} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 6 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{+} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 3 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x }\SpecialCharTok{*} \DecValTok{5}\NormalTok{) }\SpecialCharTok{{-}}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  3  8 13
\end{verbatim}

Burada önemli olan, işlemlerin her bir öğe üzerinde ayrı ayrı gerçekleştiriliyor oluşu. Eğer iki vektörümüz olsaydı,ve bu iki vektörü toplamak isteseysdik, benzer şekilde birinci öğenin ikinci vektördeki birinci öğe ile, ikinci öğenin ikinci vektördeki ikinci öğe ile vb. şekilde toplandığını görürdük.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{y }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{+}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5 7 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{*}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4 10 18
\end{verbatim}

Peki ya vektörlerimi eşit uzunlukta değilse? Bu durumda kısa olan vektor, uzun vektordeki öğeler bitene kadar tekrar tekrar kullanılır.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{)}
\NormalTok{y }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{*}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2  6  6 12
\end{verbatim}

\begin{itemize}
\tightlist
\item
  İlk vektördeki ilk eleman olan 1, ikinci vektördeki ilk eleman olan 2 ile çarpıldı ve sonucun ilk elemanı 2 oldu.
\item
  İlk vektördeki ikinci eleman olan 2, ikinci vektördeki ikinci eleman olan 3 ile çarğıldı ve sonucun ikinci elemanı 6 oldu.
\item
  İlk vektördeki üçüncü eleman olan 3, ikinci vektörde üçüncü bir eleman olmamasından dolayı ilk eleman olan 2 ile çarpıldı ve sonucun üçüncü elemanı 6 oldu.
\item
  İlk vektördeki dördüncü eleman olan 4, ikinci vektörde ikinci eleman olan 3 ile çarpıldı ve sonucun üçüncü elemanı 12 oldu.
\end{itemize}

Yani bu tarz işlemleri yaparken dikkat etmek gerekiyor. Bu işlemin sonucunda R'ın nasıl davranacağını bilmeyen birisi 8 elemanlı bir vektör almayı, yani ilk vektör önce 2 sonra 3 ile çarpıp birleştirilir diye bekleyebilir örneğin. Ancak R böyle davranmıyor.

Peki ya vektörlerimizin uzunluğu birbirinin katı olmasaydı? Burada 4 öğeli bir vektörü 2 öğeli bir vektör ile çarptık. 4 öğeli bir vektörü, 3 öğeli bir vektör ile çarpmaya çalışsaydık farklı bir davranış bekler miyiz?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{)}
\NormalTok{y }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{*}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in x * y: longer object length is not a multiple of shorter object
## length
\end{verbatim}

\begin{verbatim}
## [1] 1 4 9 4
\end{verbatim}

Hayır. Tam olarak önceki gibi bir davranış görüyoruz, ancak bu sefer R aynı zamanda bir uyarı mesajı veriyor ve vektörlerin birbirinin katı uzunlukta olmadığını söylüyor.

\hypertarget{vektuxf6r-indisleri}{%
\section{Vektör indisleri}\label{vektuxf6r-indisleri}}

Bir vektörün içindeki elemanlara ulaşmak için köşeli parantez \texttt{{[}{]}} operatorunu kullanabiliriz. Köşeli parantez içine çağırmak - ulaşmak istediğimiz öğenin indeksini, yani vektör içindeki sırasını yazarak istediğimiz elemana ulaşabiliriz. Burada önemli olan bir konu, R diğer kimi programlama dillerinin aksine 1-tabanlı indeksleme kullanıyor, yani ilk elemanın indeksi 1 (Örneğin python'da ilk elemanın indeksi 0dır).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{)}
\NormalTok{x[}\DecValTok{1}\NormalTok{] }\CommentTok{\# Birinci eleman}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{] }\CommentTok{\# Birinciden ikinciye kadar (dahil) elemanlar}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "b"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{2}\SpecialCharTok{:}\DecValTok{4}\NormalTok{] }\CommentTok{\# Ikinciden dorduncuye kadar (dahil) elemanlar}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "b" "c" "d"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\SpecialCharTok{{-}}\DecValTok{3}\NormalTok{] }\CommentTok{\# Ucuncu haric tum elemanlar}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "b" "d"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)] }\CommentTok{\# Bir ve ucuncu elemanlar}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "c"
\end{verbatim}

Gördüğünüz gibi, bu sistemle sadece tek bir eleman değil, istediğiniz alt kümeye de ulaşabilirsiniz.

Burada daha önce görmediğimiz başka bir operatör (\texttt{:}) daha kullandık. Bu operatörü, bir dizi üretmek istediğimizde kullanıyoruz.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5}\SpecialCharTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5  6  7  8  9 10
\end{verbatim}

Tekrar indekslere dönecek olursak, açıkta bıraktığımız kimi sorular var.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{)}
\CommentTok{\# olmayan bir elemani istemek NA verir}
\NormalTok{x[}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# ayni indeksi tekrar tekrar isteyerek elemanin tekrar etmesini saglayabiliriz}
\NormalTok{x[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "b" "b" "b" "c"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# elemanlari orijinal siralarina sadik kalarak cagirmak zorunda degiliz}
\NormalTok{x[}\FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "c" "a" "d"
\end{verbatim}

Ayrıca boolean vektör kullanarak vektör altkümesi almak da mümkün. Eğer ki boolean \texttt{TRUE} ise, o indekse karşılık gelen eleman elde edilen altkümede yer alır, \texttt{FALSE} ise yer almaz.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{)}
\NormalTok{x[}\FunctionTok{c}\NormalTok{(T,F,T,T)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "a" "c" "d"
\end{verbatim}

\hypertarget{isimlendirilmiux15f-vektuxf6r}{%
\section{İsimlendirilmiş vektör}\label{isimlendirilmiux15f-vektuxf6r}}

Şimdiye kadar vektör içindeki elemanları çağırmak için hangi sırada olduklarını kullanıyorduk. Oysa eğer ki vektör içindeki elemanların isimleri olsaydı bu isimleri kullanabilirdik.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myvec }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\AttributeTok{birinci=}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{,}\AttributeTok{ikinci=}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{)}
\NormalTok{myvec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## birinci  ikinci 
##     "x"     "y"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myvec[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## birinci 
##     "x"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myvec[}\StringTok{\textquotesingle{}ikinci\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ikinci 
##    "y"
\end{verbatim}

Vektöre isim atamak, örnekteki gibi \texttt{c()} fonksiyonu içinde yapılabileceği gibi, sonradan \texttt{names()} fonksiyonu kullanılarak da yapılabilir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "x" "y"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isimvektorum }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}birinci\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}ikinci\textquotesingle{}}\NormalTok{)}
\NormalTok{isimvektorum}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "birinci" "ikinci"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(a)}\OtherTok{=}\NormalTok{isimvektorum}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## birinci  ikinci 
##     "x"     "y"
\end{verbatim}

\hypertarget{listeler}{%
\chapter{Listeler}\label{listeler}}

Bir önceki konuda vektörlerin tek bir temel obje tipinden oluştuğunu söyledik. Listeler bu açıdan vektörlerden farklıdır ve birden fazla obje tipini içerebilir.

İlk olarak bir liste oluşturalım:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist }\OtherTok{=} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{)}
\NormalTok{mylist}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] "a"
\end{verbatim}

Bu sefer vektörlerde karşılaştığımız tür dönüştürme davranışı işe karşılaşmadık ve her eleman ilk girdiğimiz şekilde kaldı. Şimdi listenin 1. elemanına ulaşalım:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
\end{verbatim}

Ne yazık ki eğer listemizin birinci elemanı ile işlem yapmak istiyorsak, bu doğru bir yöntem değil. Çünkü şu anda hala 1. elemana ulaşmadık. Listelerde her eleman bir tutucu olup, bir eleman içindeki değere ulaşmak istiyorsak çift köşeli parantez kullanmamız gerekir. Farkı daha iyi görebilmek için:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{*}\DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in mylist[1] * 5: non-numeric argument to binary operator
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(mylist[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[[}\DecValTok{1}\NormalTok{]]}\SpecialCharTok{*}\DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

İlk olarak listenin birinci elemanına tek köşeli parantez ile ulaşabileceğimizi varsayıp, 5 ile çarpmaya çalıştık. Ancak hata aldık. \texttt{class()} fonksiyonunu kullanıp gördük ki, tek köşeli parantez kullandığımda elde ettiğim obje hala bir liste. Listenin elemanının içinde depolanan bilgiye erişmek içinse iki tane köşeli parantez kullandım ve bu durumda 5 ile çarpabildim.

\hypertarget{listele-indisleri}{%
\section{Listele indisleri}\label{listele-indisleri}}

Listelerin diğer çok bariz olmayan özelliklerine bakalım. Örneğin, listemizin 4.elemanından kurtulmak isteyelim:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[}\SpecialCharTok{{-}}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] TRUE
\end{verbatim}

Ya da

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] TRUE
\end{verbatim}

Bunlar tam olarak beklediğimiz gibi davranıyor ve 4. elemanı eksik liste elde ediyoruz. Peki çift köşeli parantez kullanarak, ilk üç elemandan oluşan bir vektör elde edebilir miyiz?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in mylist[[1:3]]: recursive indexing failed at level 2
\end{verbatim}

\hypertarget{listeyi-vektuxf6re-duxf6nuxfcux15ftuxfcrmek}{%
\section{Listeyi vektöre dönüştürmek}\label{listeyi-vektuxf6re-duxf6nuxfcux15ftuxfcrmek}}

Hayır. İşe yaramadı. Peki bu ne demek, listeden asla vektör oluşturamaz mıyız? Hep liste olarak mı kalacak? Hayır, bunun için de \texttt{as.vector()} fonksiyonunu kullanabiliriz.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.vector}\NormalTok{(mylist, }\AttributeTok{mode =} \StringTok{\textquotesingle{}numeric\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in as.vector(mylist, mode = "numeric"): NAs introduced by coercion
\end{verbatim}

\begin{verbatim}
## [1]  1  2  1 NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.vector}\NormalTok{(mylist, }\AttributeTok{mode =} \StringTok{\textquotesingle{}character\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1"    "2"    "TRUE" "a"
\end{verbatim}

Bu fonksiyonlar varsa da çok kullanıldıklarını söyleyemem. Her veri türünün kendine özgü avantaj ve dezavantajları var ve farklı tür veri için belli veri tipleri daha uygun olacaktır. Genelde dönüştürmeler kimi fonksiyonlar sadece vektör, ya da sadece liste tipinde objelerle çalışıyorsa gerekli olabilir. Onun dışında listeden vektöre dönüştürme işlemleri kafa karıştırıcı olabilir. Bunun bir sebebi de listelerin elemanlarının tek bir elemandan oluşma zorunluluğunun olmamasıdır.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist2 }\OtherTok{=} \FunctionTok{list}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), T, }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{)}
\NormalTok{mylist2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 0
## 
## [[2]]
## [1] 1 2
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] "a"
\end{verbatim}

Bu örnekte, listemizin ikinci elemanında iki elemanlı bir vektör sakladık. Şimdi az önceki yöntemi kullanmaya çalışırsak:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.vector}\NormalTok{(mylist2, }\AttributeTok{mode =} \StringTok{\textquotesingle{}numeric\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in as.vector(mylist2, mode = "numeric"): 'list' object cannot be coerced to type 'double'
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.vector}\NormalTok{(mylist2, }\AttributeTok{mode =} \StringTok{\textquotesingle{}character\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0"       "c(1, 2)" "TRUE"    "a"
\end{verbatim}

İkisi de beklediğimiz gibi bir sonuç değil. Eğer ki elde etmek istediğimiz vektör \texttt{c(\textquotesingle{}0\textquotesingle{},\ \textquotesingle{}1\textquotesingle{},\ \textquotesingle{}2\textquotesingle{},\ \textquotesingle{}T\textquotesingle{},\ \textquotesingle{}a\textquotesingle{})} vektörü ise, \texttt{unlist()} fonksiyonunu kullanabiliriz.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{unlist}\NormalTok{(mylist2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0"    "1"    "2"    "TRUE" "a"
\end{verbatim}

\hypertarget{listelerde-aritmetik-iux15flemler}{%
\section{Listelerde aritmetik işlemler}\label{listelerde-aritmetik-iux15flemler}}

Şimdi bir de vektörler üzerinde yaptığımız işlemler listeler üzerinde de geçerli mi ona kısaca göz atalım. İlk olarak eşlenik olarak değerlendirebileceğimiz bir vektör objesi (myvec) ve liste objesi (mylist) yaratalım:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myvec }\OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}
\NormalTok{myvec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist }\OtherTok{=} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{mylist}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
\end{verbatim}

Vektörler konusunda gördüğümüz kimi işlemlerin üzerinden geçip, listeler üzerinde de geçerli olup olmadıklarına bakalım. İlk olarak birleştirme işlemi:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(myvec, myvec)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(mylist, mylist)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
## 
## [[4]]
## [1] 1
## 
## [[5]]
## [1] 2
## 
## [[6]]
## [1] 3
\end{verbatim}

Yani, evet! Listeleri de birleştirebiliyoruz. Peki aritmetik işlemler?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myvec }\SpecialCharTok{*} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3 6 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist }\SpecialCharTok{*} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in mylist * 3: non-numeric argument to binary operator
\end{verbatim}

Hayır, aritmetik işlemleri yapabilmek için listenin elemanlarına tek tek erişmeliyiz.

\hypertarget{isimlendirilmiux15f-liste}{%
\section{İsimlendirilmiş liste}\label{isimlendirilmiux15f-liste}}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(myvec) }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)}
\NormalTok{myvec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a b c 
## 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(mylist) }\OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{)}
\NormalTok{mylist}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $a
## [1] 1
## 
## $b
## [1] 2
## 
## $c
## [1] 3
\end{verbatim}

Evet, isimlendirme de çalışıyor! Peki isimli listede alt küme alma işlemleri nasıl oluyor?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myvec[}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a 
## 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $a
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist[[}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

Aynı indismiş gibi isimleri kullanarak da liste elemanlarına ulaşabiliyoruz. Ancak listelerde aynı amaçla kullanabileceğimiz başka bir operatör daha var: \texttt{\$}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mylist}\SpecialCharTok{$}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

Ve bu operatör çift köşeli paranteze denk işliyor, görüdüğünüz gibi liste tipinde bir obje değil, direkt olarak ilk eleman içine kaydedilen bilgiye ulaştık. Peki bu vektörlerde de çalışır mı?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myvec}\SpecialCharTok{$}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in myvec$a: $ operator is invalid for atomic vectors
\end{verbatim}

Hayır!

\hypertarget{matrisler}{%
\chapter{Matrisler}\label{matrisler}}

Matrisler, iki boyutta düzenlenmiş verilerdir, yanyana ya da altalta dizilenmis vektör gibi düşünülebilirler. İkişer elemanlı 3 vektörümüz oldugunu düşünelim:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{2}
\NormalTok{b }\OtherTok{\textless{}{-}} \DecValTok{3}\SpecialCharTok{:}\DecValTok{4}
\NormalTok{c }\OtherTok{\textless{}{-}} \DecValTok{5}\SpecialCharTok{:}\DecValTok{6}
\end{Highlighting}
\end{Shaded}

Şimdi bunları yanyana birleştirip, iki satır üç sütunlu bir matris oluşturalım. Bunun için \texttt{cbind()} yani, column-bind (sütun bağlama) fonksiyonunu kullanacağız.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cbind}\NormalTok{(a, b, c)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      a b c
## [1,] 1 3 5
## [2,] 2 4 6
\end{verbatim}

Aynı şekilde \texttt{rbind()} yani row-bind (satır bağlama) fonksiyonu ile bu vektörleri satır satır birleştirip, 3 satır iki sutunlu bir matris de elde edebiliriz:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rbind}\NormalTok{(a, b, c)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [,1] [,2]
## a    1    2
## b    3    4
## c    5    6
\end{verbatim}

Her satır ve sütunu ayrı ayrı vektör şeklinde birleştirerek matris oluşturmak yerine \texttt{matrix()} fonksiyonunu da kullanabiliriz.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
\end{verbatim}

Burada 1den 9a kadar sayıları 3 sütuna (ncol = 3 ile belirttik) yerleştirdik. Aynı şekilde satır sayısını da girebilirdik (nrow). \texttt{matrix()} fonksiyonu ile kullanabileceğimiz bir diğer argüman ise \texttt{byrow} argümanı. Önceki örnekte 1den 9a kadar sayıları içeren bir vektör oluşturup 3 sütuna bölmüştük. Bu fonksiyon varsayılan argümanlarla çalıştırıldığında önce birinci sütunu doldurup sonra ikinciye geçiyor. Eğer bunun yerine önce satırları doldurmasını istersek:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{3}\NormalTok{, }\AttributeTok{byrow =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
\end{verbatim}

Şimdi 1:3 birinci satırı, 4:6 ikinci satırı oluşturdu.

\hypertarget{matris-boyutlarux131}{%
\section{Matris boyutları}\label{matris-boyutlarux131}}

Bunlar dışında matrislerin vektörlerden bir farkı da boyut özelliğinin olması. Oysa vektörlerde uzunluk özelliğimiz vardır. Şu örneklere bakalım:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(a, b, c)}
\FunctionTok{length}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

`mymat' objesinin boyuna bakmak istediğimizde toplam eleman sayısı olan 6yı veriyor. Oysa bu kaç satır ve sütundan oluştuğu bilgisini vermediğinden, matrisin yapısını anlamamızı zorlaştırıyor. Bu bilgiyi öğrenmek için \texttt{dim()} fonksiyonunu kullanacağız.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 3
\end{verbatim}

Burada önemli olan bir bilgi, dim() fonksiyonu ilk olarak satır sayısını sonra sütun sayısını yazar. Son olarak \texttt{dim()} fonksiyonunun vektörler üzerinde işe yaramayacağını görelim:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

\hypertarget{matris-indisleri}{%
\section{Matris indisleri}\label{matris-indisleri}}

Matris içindeki verilere ulaşmak için yine köşeli parantez kullanılabilir. Ancak bu sefer birden fazla boyut olduğundan satır ve sütunu virgül ile ayırarak yazacağız. Örneğin:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      a b c
## [1,] 1 3 5
## [2,] 2 4 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## b c 
## 3 5
\end{verbatim}

\texttt{mymat{[}1,\ 2:3{]}} kodu ile, mymat matrisinin 1. satırının 2den 3e kadar olan elemanlarını istemiş oluyoruz.

\hypertarget{aritmetik-iux15flemler}{%
\section{Aritmetik işlemler}\label{aritmetik-iux15flemler}}

Aynı vektörlerde olduğu gibi aritmetik işlemler yapmak da mümkün.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat }\SpecialCharTok{*} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      a  b  c
## [1,] 3  9 15
## [2,] 6 12 18
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat }\SpecialCharTok{+} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      a b c
## [1,] 3 5 7
## [2,] 4 6 8
\end{verbatim}

Peki ya uzunluğu birden büyük bir vektör ile işlem yapmak istersek?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      a b c
## [1,] 1 3 5
## [2,] 2 4 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat }\SpecialCharTok{*} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      a b  c
## [1,] 1 3  5
## [2,] 4 8 12
\end{verbatim}

Bunu anlamak için matrisin ilk üç elemanına bakalım:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

Virgül ile satır ve sütun ayırmadığımızdan elde ettiğimiz obje de matrisin ilk 3 elemanından oluşan bir vektör oldu. Buradan gördüğümüz gibi matrisin birinci elemanı ilk satır ilk sütunda, ikinci elemanı ilk sütün ikinci satırda - ve sonra diğer sütunlara geçiyoruz. Bu matrisi bir vektör ile işlem yapmak istediğimizde de aynı vektörlerde olduğu gibi önce birinci eleman vektördeki birinci elemanla, ikinci eleman vektördeki ikinci elemanla işleme giriyor. Vektördeki elemanlar bittiğinden tekrar başa dönüyoruz ve matrisin üçüncü elemanı vektörün ilk elemanı ile işleme giriyor ve böyle devam ediyor. Bu işlemin satır ve sütun sayısıyla alakalı olmadığını göstermek adına bir başka örnek:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat }\SpecialCharTok{*} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      a b  c
## [1,] 1 9 10
## [2,] 4 4 18
\end{verbatim}

Matris transpozu, satır ve sütunların yer değiştirmesi işlemidir ve \texttt{t()} fonksiyonu ile gerçekleştirilir.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{t}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [,1] [,2]
## a    1    2
## b    3    4
## c    5    6
\end{verbatim}

Önceki örnekler matris çarpımı değil, matris içindeki değerlerin başka bir skalar ya da vektörle çarpımına örnekti. Rda matris çarpımı, ya da matris nokta çarpımı, yapmak da mümkün ve bu \texttt{\%*\%} operatörü ile yapılabilir. İki matrisin nokta çarpımı işlemine girebilmesi için birinci matrisin sütün sayısının, ikinci matrisin satır sayısına eşit olması gerekir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat2 }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{1}\NormalTok{)}
\NormalTok{mymat2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1]
## [1,]    1
## [2,]    2
## [3,]    3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat }\SpecialCharTok{\%*\%}\NormalTok{ mymat2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1]
## [1,]   22
## [2,]   28
\end{verbatim}

Bir matrisin tersi, kendisi ile çarpıldığında birim matrisi verir ve Rda \texttt{solve()} fonksiyonu ile hesaplanabilir. Bu işlem ancak kare matrisler üzerinde gerçekleştirilebilir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat }\OtherTok{=} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{), }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{mymat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    8    6
## [2,]    4    9    5
## [3,]    3    2    7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{solve}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             [,1]        [,2]        [,3]
## [1,] -0.32121212  0.26666667  0.08484848
## [2,]  0.07878788  0.06666667 -0.11515152
## [3,]  0.11515152 -0.13333333  0.13939394
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat }\SpecialCharTok{\%*\%} \FunctionTok{solve}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##              [,1]          [,2]         [,3]
## [1,] 1.000000e+00 -1.110223e-16 1.110223e-16
## [2,] 1.110223e-16  1.000000e+00 0.000000e+00
## [3,] 2.220446e-16 -2.220446e-16 1.000000e+00
\end{verbatim}

Bunlar dışında sık kullanılan matris işlemleri için \texttt{crossprod()}, \texttt{det()}, \texttt{eigen()}, \texttt{svd()} gibi fonksiyonlar da temel Rda mevcuttur.

Son olarak, matrislerle çalışırken kolaylaştırıcı \texttt{rowMeans()}, \texttt{colMeans()}, \texttt{rowSums()}, \texttt{colSums()} gibi satır / sütun ortalamalarına ve toplamlarına erişmek için fonksiyonlar mevcut.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymat}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    8    6
## [2,]    4    9    5
## [3,]    3    2    7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rowSums}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 15 18 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{colSums}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  8 19 18
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rowMeans}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5 6 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{colMeans}\NormalTok{(mymat)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.666667 6.333333 6.000000
\end{verbatim}

\hypertarget{faktorler}{%
\chapter{Faktorler}\label{faktorler}}

Faktörler kategorik verilerle uğraşırken kullandığımız verilerdir. Yani değişkenimiz sadece belli bir set içinden değer alabilir.

Faktör oluşturmak için \texttt{factor()} fonksiyonunu kullanabiliriz. Diyelim ki sadece elma, armut, ya da muz olabilen bir verimiz olsun.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}}  \FunctionTok{c}\NormalTok{(}\StringTok{"elma"}\NormalTok{, }\StringTok{"muz"}\NormalTok{, }\StringTok{"elma"}\NormalTok{, }\StringTok{"armut"}\NormalTok{, }\StringTok{"muz"}\NormalTok{)}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "elma"  "muz"   "elma"  "armut" "muz"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a\_f }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(a)}
\NormalTok{a\_f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] elma  muz   elma  armut muz  
## Levels: armut elma muz
\end{verbatim}

Burada a ve a\_f objeleri bir kaç açıcan birbirinden farklı. Değerler aynı gibi görülebilir ancak a objemiz bir karakter objesidir. a\_f ise bir faktör objesidir ve karşılık aldığı değerler karakter değil, alabileceği kategorik değişkenlerin sayısıdır. Bunu daha iyi anlamak açısından:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: NAs introduced by coercion
\end{verbatim}

\begin{verbatim}
## [1] NA NA NA NA NA
\end{verbatim}

Bu karakterleri nümerik tipe dönüştürmek mümkün olmadığından NA'lardan oluşan bir vektör elde ediyoruz. Aynısını a\_f'ye yapalım:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a\_f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] elma  muz   elma  armut muz  
## Levels: armut elma muz
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(a\_f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 3 2 1 3
\end{verbatim}

Şimdi NA yerine sayılar aldık. Bu sayılar da değerlerin faktörün alabileceği değerler arasından kaçıncı olduğuna denk geliyor. a\_f'nin ``levels'' yani alabileceği değerler sırasıyla armut, elma, muz olduğundan, armut 1, elma 2, muz ise 3 oluyor. Burada değerlerin sıralaması varsayılan olarak alfabetik olarak yapılıyor. Ancak bunu değiştirmemiz mümkün:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a\_f }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(a, }\AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}\StringTok{"elma"}\NormalTok{,}\StringTok{"armut"}\NormalTok{, }\StringTok{"muz"}\NormalTok{))}
\NormalTok{a\_f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] elma  muz   elma  armut muz  
## Levels: elma armut muz
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(a\_f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 3 1 2 3
\end{verbatim}

Karakterlerle çalışırken faktörleri anlamak görece daha kolay olabilir. Ancak özellikle nümerik kategorilerimiz varsa, objenin faktör olduğunu farketmemek analizimizi çok kötü bir çıkmaza götürebilir ve en sık yapılan hatalardan biridir.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{a\_f }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

Şimdi 30u a ve a\_f vektörüne böldüğümüzde karşımıza ne çıkıyor bakalım:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{30}\SpecialCharTok{/}\FunctionTok{as.numeric}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30 15  6  3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{30}\SpecialCharTok{/}\FunctionTok{as.numeric}\NormalTok{(a\_f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30.0 15.0 10.0  7.5
\end{verbatim}

Gördüğünüz gibi a\_f'deki değerler nümerik hale dönüştürüldüğünde kendi nümerik değerlerini değil 1,2,3 ve 4 değerlerini aldığından işlem yanlış oldu. Bu özellikle R'a csv ya da excel dosyasından veri okunduğunda karşılaşılan bir problem.

Peki diyelim ki yanlışlıkla nümerik verimizi a\_f gibi, faktör olarak okuduk. Bundan geri dönüş yok mu? Veriyi önce karakter sonra nümerik olarak alırsak sorun ortadan kalkıyor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a\_f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1  2  5  10
## Levels: 1 2 5 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.character}\NormalTok{(a\_f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1"  "2"  "5"  "10"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{as.character}\NormalTok{(a\_f))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  2  5 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{30} \SpecialCharTok{/}\NormalTok{ a }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30 15  6  3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{30} \SpecialCharTok{/} \FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{as.character}\NormalTok{(a\_f))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30 15  6  3
\end{verbatim}

Gördüğünüz gibi aynı sonucu aldık. Diğer bir çözüm de değerleri alabilecekleri seviyeleri kullanarak gerçek değerleri haline getirerek olabilir:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{levels}\NormalTok{(a\_f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1"  "2"  "5"  "10"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{30} \SpecialCharTok{/} \FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{levels}\NormalTok{(a\_f)[a\_f])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30 15  6  3
\end{verbatim}

Birebir bize çok yansımasa da faktörün en büyük yararı verinin depolanmasıyla ilgili. Diyelim ki elimizde 1 milyon kişinin doğduğu ay bilgisi var. Bunu karakter olarak kaydetmek yerine faktör olarak kaydedersek sadece her birey için 1den 12ye kadar birer sayı kaydedilir ve bir de bu sayıların karşılık geldiği değerler. Bu bütün ayların bütün karakterleriyle tek tek yazılmasından oldukça verimli bir çözümdür. read.table'ın değişkenleri faktör olarak okuma eğilimi de bundan kaynaklıdır.

Diğer önemli bir detay da faktör'e \texttt{c()} fonskiyonu ile yeni bir değer eklemekle ilgili. Bunu yapamayız:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a\_f}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1  2  5  10
## Levels: 1 2 5 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(a\_f, }\DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(a\_f, }\StringTok{"armut"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1"     "2"     "3"     "4"     "armut"
\end{verbatim}

Gördüğünüz gibi aynı \texttt{as.numeric()} fonksiyonunda karşılaştığımız gibi tüm değerler sıralamaya yani 1, 2, 3, ve 4e dönüştürülüp sonradan ekleme yapılıyor. Peki faktör vektörüne yeni değer ekleyemez miyiz?

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{factor}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{as.character}\NormalTok{(a\_f)),}\DecValTok{8}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1  2  5  10 8 
## Levels: 1 2 5 8 10
\end{verbatim}

Genel olarak yapmak istediğinizi yapacak hale getirmeniz mümkün ama özellikle tidyverse'te \texttt{forcats} paketini kullanmıyorsanız, çok da gerekli olmadıkça, özellikle başlangıç seviyesindeyken faktörlerden uzak durup, karakter ve nümerik verilerle çalışmanızı tavsiye ederim. Bu faktörler yararlı olmadığından değil, alışkın olana kadar çalışması zor olduğundan. Faktörlerin özellikle yararlı olduğu bir kaç kullanım:

\emph{1) Modelleme:} Faktörlerin en yaygın kullanımı modelleme yaparken karşımıza çıkıyor. Değişkenleri sürekli değişkenler olarak değil de faktör olarak kaydettiğimizde, modelde doğru şekilde yer almasını sağlayabiliyoruz. Ayrıca çoğu model fonksiyonları karakter vektörü aldıklarında çalışmayabiliyor.

\emph{2)\texttt{table} fonksiyonu ile kullanım:} Diyelim ki 5 değer alabilen bir değişkeniniz var. Ama elinizdeki örneklem bu 5 değerin sadece 3ünü içeriyor. \texttt{table()} fonksiyonunu kullanarak her değerin kaç kez geçtiğini özetleyebilirsiniz ancak eğer faktörse bu özet 5 değerin tümünü içerirken, karakter ya da nümerik olduğunda 3 değer içerir:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OtherTok{\textless{}{-}}  \FunctionTok{c}\NormalTok{(}\StringTok{"elma"}\NormalTok{, }\StringTok{"muz"}\NormalTok{, }\StringTok{"elma"}\NormalTok{, }\StringTok{"armut"}\NormalTok{, }\StringTok{"muz"}\NormalTok{)}
\FunctionTok{table}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a
## armut  elma   muz 
##     1     2     2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a\_f }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(a, }\AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}\StringTok{"elma"}\NormalTok{,}\StringTok{"muz"}\NormalTok{,}\StringTok{"armut"}\NormalTok{,}\StringTok{"karpuz"}\NormalTok{,}\StringTok{"çilek"}\NormalTok{))}
\FunctionTok{table}\NormalTok{(a\_f)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a_f
##   elma    muz  armut karpuz  çilek 
##      2      2      1      0      0
\end{verbatim}

Bu özellik kimi zaman kullanışlı olabilir.

\emph{3) Büyük veri ile çalışırken:} Daha önce de bahsettiğim gibi faktörler özellikle büyük veri ile çalışırken tekrarlı veri söz konusu ile ciddi yer kazancı sağlamanız anlamına gelebilir.

  \bibliography{lib.bib}

\end{document}
